/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from 'react'
import { useGLTF, Center, Stage, Text3D} from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { useEffect } from 'react'
import { Button } from '@chakra-ui/react'

export function Model(props) {
  const { nodes, materials } = useGLTF('/whitepirate.glb')
  const bones = ['Head','Neck','Spine2']
  let originPositions = []
  function getOrigins(){
    bones.map( (d)=>{
      originPositions.push({ [d] :nodes[d].rotation})
    })
    console.log(originPositions)
  }

  useEffect( () => getOrigins(),[]);
  console.log(originPositions)
  useFrame( (state) => {
    // if(state.mouse){
      let rotY = THREE.MathUtils.degToRad(state.mouse.x) * 10
      let rotX = THREE.MathUtils.degToRad(state.mouse.y) * -10
      nodes.Head.rotation.y = THREE.MathUtils.lerp(nodes.Head.rotation.y, rotY, 0.5);
      nodes.Head.rotation.x = THREE.MathUtils.lerp(nodes.Head.rotation.x, rotX, 0.05);
      nodes.Neck.rotation.y = THREE.MathUtils.lerp(nodes.Head.rotation.y, rotY, 0.5);
      nodes.Neck.rotation.x = THREE.MathUtils.lerp(nodes.Head.rotation.x, rotX, 0.05);
      nodes.Spine2.rotation.y = THREE.MathUtils.lerp(nodes.Spine2.rotation.y, rotY, 0.01);
      nodes.Spine2.rotation.x = THREE.MathUtils.lerp(nodes.Spine2.rotation.x, rotX, 0.01);
    // }
    
    // if(props.reset) {
    //   console.log(originPositions.Head)
    //   nodes.Head.rotation.y += originPositions.Head._y
    //   nodes.Head.rotation.x = originPositions.Head._x

    //   // nodes.Head.rotation.y = THREE.MathUtils.lerp(nodes.Head.rotation.y, originPositions.Head.y, 0.5);
    //   // nodes.Head.rotation.x = THREE.MathUtils.lerp(nodes.Head.rotation.x, originPositions.Head.x, 0.05);

    //   // nodes.Neck.rotation.y = THREE.MathUtils.lerp(nodes.Neck.rotation.y, originPositions.Neck.y, 0.5);
    //   // nodes.Neck.rotation.x = THREE.MathUtils.lerp(nodes.Neck.rotation.x, originPositions.Neck.x, 0.05);

    //   // nodes.Spine2.rotation.y = THREE.MathUtils.lerp(nodes.Spine2.rotation.y, originPositions.Spine2.y, 0.01);
    //   // nodes.Spine2.rotation.x = THREE.MathUtils.lerp(nodes.Spine2.rotation.x, originPositions.Spine2.x, 0.01);
    // }
  })

  return (
    <group {...props} dispose={null}>
      <group position={[1.5, 1.5, 0]} rotation={[Math.PI / 2, 0, 0]} scale={0.27}>
        <primitive object={nodes.Hips} />
        <skinnedMesh geometry={nodes.Beard.geometry} material={materials.Beard_Material} skeleton={nodes.Beard.skeleton} />
        <skinnedMesh geometry={nodes.Belt.geometry} material={materials.lambert2SG} skeleton={nodes.Belt.skeleton} />
        <skinnedMesh geometry={nodes.Belt_2.geometry} material={materials.Pirate_Material} skeleton={nodes.Belt_2.skeleton} />
        <skinnedMesh geometry={nodes.Cutlass.geometry} material={materials.Material} skeleton={nodes.Cutlass.skeleton} />
        <skinnedMesh geometry={nodes.Eye_L.geometry} material={materials.lambert2SG} skeleton={nodes.Eye_L.skeleton} />
        <skinnedMesh geometry={nodes.Eye_R.geometry} material={materials.lambert2SG} skeleton={nodes.Eye_R.skeleton} />
        <skinnedMesh geometry={nodes.Hat.geometry} material={materials.lambert2SG} skeleton={nodes.Hat.skeleton} />
        <skinnedMesh geometry={nodes.Pirate.geometry} material={materials.Material} skeleton={nodes.Pirate.skeleton} />
        <skinnedMesh geometry={nodes.Pistol_1.geometry} material={materials.lambert2SG} skeleton={nodes.Pistol_1.skeleton} />
        <skinnedMesh geometry={nodes.Pistol_2.geometry} material={materials.lambert2SG} skeleton={nodes.Pistol_2.skeleton} />
        <skinnedMesh geometry={nodes.Sword_Scabbard.geometry} material={materials.lambert2SG} skeleton={nodes.Sword_Scabbard.skeleton} />
      </group>
      {/* <Center>
        <Text3D ref={textRef} font={'/Maven Pro_Regular.json'} {...textOptions}> 
          WHITE PIRATE BLOCKCHAIN SECURITY
          <meshNormalMaterial />
        </Text3D>
      </Center> */}
    </group>
  )
}

const getMousePos = (e) => ( { x: e.clientX, y: e.clientY } )

function moveJoint(mouse, joint, degreeLimit) {
  let degrees = getMouseDegrees(mouse.x, mouse.y, degreeLimit);
  joint.rotation.y = THREE.MathUtils.lerp(joint.rotation.y, THREE.MathUtils.degToRad(degrees.x), 0.1);
  joint.rotation.x = THREE.MathUtils.lerp(joint.rotation.x, THREE.MathUtils.degToRad(degrees.y), 0.1);
}

function getMouseDegrees(x, y, degreeLimit) {
  let dx = 0,
      dy = 0,
      xdiff,
      xPercentage,
      ydiff,
      yPercentage;

  let w = { x: window.innerWidth, y: window.innerHeight };

  // Left (Rotates neck left between 0 and -degreeLimit)
  
   // 1. If cursor is in the left half of screen
  if (x <= w.x / 2) {
    // 2. Get the difference between middle of screen and cursor position
    xdiff = w.x / 2 - x;  
    // 3. Find the percentage of that difference (percentage toward edge of screen)
    xPercentage = (xdiff / (w.x / 2)) * 100;
    // 4. Convert that to a percentage of the maximum rotation we allow for the neck
    dx = ((degreeLimit * xPercentage) / 100) ; }
// Right (Rotates neck right between 0 and degreeLimit)
  if (x >= w.x / 2) {
    xdiff = x - w.x / 2;
    xPercentage = (xdiff / (w.x / 2)) * 100;
    dx = (degreeLimit * xPercentage) / 100;
  }
  // Up (Rotates neck up between 0 and -degreeLimit)
  if (y <= w.y / 2) {
    ydiff = w.y / 2 - y;
    yPercentage = (ydiff / (w.y / 2)) * 100;
    // Note that I cut degreeLimit in half when she looks up
    dy = ((degreeLimit * yPercentage) / 100) * -1;
    }
  
  // Down (Rotates neck down between 0 and degreeLimit)
  if (y >= w.y / 2) {
    ydiff = y - w.y / 2;
    yPercentage = (ydiff / (w.y / 2)) * 100;
    dy = (degreeLimit * yPercentage) / 100;
  }
  return { x: dx, y: dy };
}

useGLTF.preload('/whitepirate.glb')
